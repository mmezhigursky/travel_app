<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Steps to Install Webpack</title></head><body><div id="steps"><h2>Steps to Configure Webpack (Conceptual Tutorial)</h2><ol><li><h3>Install webpack and webpack-cli</h3></li><li><h3>Entry Point</h3><p>Till this point, webpack doesn't know where to start building its dependency tree. It needs a starting point. In this project, our entry is './src/client/index.html'. This is the file from where webpack will start building its dependency tree. This file doesn't exist yet - you'd get an error. So go ahead and create a file index.js within client folder (and don't confuse this file with index.js file in server folder). Add some JS to this file to see that it gets reflected in the main.js file. Now when you run webpack, webpack will generate a folder 'dist' and it will contain the output JS files that'd be condensed</p></li><li><h3>Output and Loaders</h3><h4>Output</h4><p>There is a problem with the main.js file that has been generated by webpack - it has no connection to our view till now. So, we go to our view (index.html) and remove references to all our assets (JS and CSS files) and replace it with only one hard-coded reference to main.js file. Although this step is temporary as eventually this reference to main.js file will also be dynamic and will be made by webpack in the future.</p><p>Second issue is that all of the JS files that are there in JS folder has no connection to the main.js we created. We need to bring these files into the index.js file that we created in client folder. We cannot just require files as we are dealing with client side and all the code needs to be referenced in one file. For this, we use a tool called Babel.</p><h4>Loaders</h4><p>Babel is a specialized tool that translates one version of Javascript file into another. It allows developers to use newer versions of JS like ES6 even though browsers don't understand ES6 yet - it converts ES6 JS into older native JS that is interpreted by browers.</p><p>Using Babel, we can import functions into the index.js file - Use the keyword <em>import</em> in front of functions in the index.js file and add the keyword <em>export</em> to functions in the source JS files</p></li><li><h3>Plugins</h3><p>While Loaders are used to transform certain types of modules, Plugins are used to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p><p>So pretty much that falls outside Loaders will be covered by Plugins.</p><p>Plugins can automatically add asset references to an HTML file, which would be done in this project (HTML Webpack Plugin). Earlier we hard-coded reference to main.js file in index.html file. We would remove that hard-coded reference and HTML webpack plugin would automatically reference to that file. At the end of the file, before the closing body tag.</p><p>This is the step at which a new file - index.html would be created in dist folder. It would automatically reference to the main.js file.</p><p>Don't forget to manually remove the hard-coded reference to main.js file in source index.html file!</p></li><li><h3>Modes</h3><p>Developers refer to the various states of a website as environments.</p></li><li><h3>Convenience in Webpack</h3><h4>WebPack Dev Server</h4><p>Webpack Dev Server is a server for development mode only that allows to fun files and updates immediately. With it, you don't have to refresh the browser to see the changes. This feature is also called hot reloading.</p><p>PS: When using webpack dev server, the dist folder is not created - something that should be mentioned in the course lessons.</p><h4>Webpack Clean Plugin</h4><p>This plugin automatically delete files from output.path directory, as well as any unused asset after every successful build</p><p>To go old school, you can chooose the below script that deletes everything and then re-builds everything:<br/><em><b>rm -rf dist && webpack-dev-server --config webpack.dev.js --open</b></em></p></li><li><h3>SASS Loader</h3><p>Sass loader converts sass/scss files to vanilla css that can be interpreted by the browser.</p></li><li><h3>Fix Functionality</h3><p>Since all the variables are packaged into layers, the scope isn't global anymore. Hence, the output of the files is made into a library and all the functions are referenced using this library. This makes all the functions accessible.</p></li><li><h3>Webpack for Production</h3><p>Webpack minifies a lot of our styles when the mode is set to Production. In dev server, all the styles are passed into main.js file as inline styles. Inline styles are slower and hence in production mode, they are separated in a main.css file. This file is minified. Hence, we add MinifyCssExtractPlugin</p></li><li><h3>Terser Plugin and OptimizeCSSAssetPlugin</h3><p>These plugins minimizing action on certain files.</p></li><li><h3>Service Workers</h3><p>Service workers is the piece of JS that runs between the app and the internet and allow for offline interactions. They run in the background and offer functionalities like push notifications. Mostly used in PWAs.</p></li></ol><hr><div id="commands"><h2>Command and technical steps that'd be needed to configure webpack</h2><ol><li><h3>Install express and other requirements (if not already installed)</h3><p><em><b>npm install express<br>npm install body-parser<br>npm install cors</b></em></p></li><li><p>Install webpack: <em><b>npm i webpack webpack-cli</b></em></p><p>Once done, make sure webpack and webpack-cli are added as dependencies in package.json file.</p><p>Create the config file - Create webpack.config.js file, which will hold all the configurations. Eventually, there will be 2 versions of this file - one for dev and one for production</p><p>Require s tatements and export.modules (don't forget the 's'!) - Add necessary require statements and module.exports rules. Add "build": "webpack" script to package.json</p></li><li><p>Install Babel: <em><b>npm i -D @babel/core @babel/preset-env babel-loader</b></em></p><p>-D denotes that the installation would be done in development environment. They need not to be present in the production environment and be presenet when we are serving the application to our users.</p><p>Create a .babelrc file at root (right next to the webpack config file) and add this code to the file - { ‘presets’: ['@babel/preset-env'] }</p><p>Add rules in the webpack config file:</p><p><em><b>module: { rules: [ { test: '/\.js$/', exclude: /node_modules/, loader: "babel-loader" } ], { "targets": { "browsers": ["last 2 chrome versions"] }, "useBuiltIns": "usage" } }</b></em></p></li><li><p>Install HTML Webpack Plugin - <em><b>npm i -D html-webpack-plugin</b></em></p><p>Require that plugin in webpack config file - <em><b>const HtmlWebPackPlugin = require('html-webpack-plugin');</b></em></p><p>Add the plugin section in export.modules: <em><b>plugins: [ new HtmlWebPackPlugin({ template: "./src/client/views/index.html", filename: "./index.html", }),</b></em></p><p>Right now our server doesn't know that we have this plugin installed. Hence, it is referencing to the index.html file in the src/client folder. Go to that file and change the file reference from that to the dist folder - <em><b>res.sendFile('dist/index.html')</b></em></p><p>Also, update the server to look for this file in the dist folder and not src/client: <em><b>app.use(express.static('dist'))</b></em></p></li><li><p>Add a mode attibute to module.exports - <em><b>mode: 'production'</b></em></p><p>Create another variant of the webpack config file - one for production and one for development</p><p>Have 2 npm scripts in the package.json file - one development and one for production:<br/><em><b>"build-prod": "webpack --config webpack.prod.js",<br/>"build-dev": "webpack --config webpack.dev.js"</b></em></p></li><li><p>Install Webpack Dev Server - <em><b>npm i webpack-dev-server</b></em></p><p>Edit the build-dev script with: <em><b>"build-dev": "webpack-dev-server --config webpack.dev.js --open</b></em></p></li><li><p>Install Webpack Clean Plugin: <em><b>npm i -D clean-webpack-plugin</b></em></p><p>Add a require statement at the top of the webpack config file: <em><b>const { CleanWebpackPlugin } = require('clean-webpack-plugin');</b></em></p><p>Add it to the module.exports array: <em><b>new CleanWebpackPlugin({ // Simulate the removal of files dry: true, // Write Logs to Console verbose: true, // Automatically remove all unused webpack assets on rebuild cleanStaleWebpackAssets: true, protectWebpackAssets: false })</b></em></p></li><li><p>Install SASS loader: <em><b>npm i -D style-loader node-sass css-loader sass-loader</b></em></p><p>Add rule to module.exports:<br/><em><b>{ test: /\.scss$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] }</b></em></p><p>Add scss files in depende tree (in index.html file). Eg: <em><b>import './styles/resets.scss'</b></em></p></li><li><p>Fix the functionality. Add below output rule: <em><b>output: { libraryTarget: 'var', library: 'Client' }</b></em></p><p>Export JS file into this new library: <em><b>export { checkForName, handleSubmit }</b></em></p><p>Replace existing function references with library name. Eg: Change onClick funtion in HTML file to Client.handleSubmit(event)</p></li><li><p>Install MinifyCssExtractPlugin: <em><b>npm i mini-css-extract-plugin</b></em></p><p>Require it in the webpack config file and add it to the plugins module.</p><p><b>Replace the Sass loader with MinifyCssExtract loader</b></p></li><li><p>Install optimization plugins:<br><em><b>npm i optimize-css-assets-webpack-plugin<br>npm i terser-webpack-plugin</b></em></p><p>Add this optimization code to module.exports: <em><b>optimization: { minimizer: [new TerserPlugin({}), new OptimizeCSSAssetsPlugin({})]}</b></em></p></li><li><p>Install the plugin: <em><b>npm install workbox-webpack-plugin --save-dev</b></em></p><p>Require the plugin in prod: <em><b>const WorkboxPlugin = require('workbox-webpack-plugin');</b></em></p><p>Add the plugin: <em><b>new WorkboxPlugin.GenerateSW()</b></em></p><p>Final step - We need to register a service worker with our app. Add the below script to HTML file, just before the closing body tag:<br/><em><b><opening script tag>// Check that service workers are supported if ("serviceWorker" in navigator) { // Use the window load event to keep the page load performant window.addEventListener("load", () => { navigator.serviceWorker.register("/service-worker.js"); }); }<closing script tag></closing></opening></b></em></p></li></ol></div></div><script src="bundle.min.js"></script></body></html>